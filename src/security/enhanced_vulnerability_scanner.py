"""
Enhanced Vulnerability Scanner for Privatus-chat

This module provides advanced vulnerability scanning capabilities including:
- Advanced static analysis with control flow tracking
- Dynamic application security testing (DAST)
- Interactive application security testing (IAST)
- Container and dependency vulnerability scanning
- Network service vulnerability assessment
- Configuration security analysis
- Custom vulnerability rule engine
"""

import ast
import json
import logging
import os
import re
import socket
import ssl
import subprocess
import threading
import time
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Dict, List, Any, Optional, Set, Tuple, Callable
from urllib.parse import urlparse
import asyncio
import aiohttp
import aiofiles
import concurrent.futures


class VulnerabilitySeverity(Enum):
    """Enhanced vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"


class VulnerabilityCategory(Enum):
    """Vulnerability categories."""
    CRYPTOGRAPHY = "cryptography"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    OUTPUT_ENCODING = "output_encoding"
    CONFIGURATION = "configuration"
    NETWORK = "network"
    DEPENDENCY = "dependency"
    BUSINESS_LOGIC = "business_logic"
    MEMORY_SAFETY = "memory_safety"


@dataclass
class VulnerabilityFinding:
    """Enhanced vulnerability finding with detailed information."""

    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: VulnerabilityCategory
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    column_number: Optional[int] = None
    code_snippet: Optional[str] = None
    evidence: List[str] = field(default_factory=list)
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    false_positive: bool = False
    verified: bool = False
    discovered_at: datetime = field(default_factory=datetime.now)
    tags: Set[str] = field(default_factory=set)

    def to_dict(self) -> Dict[str, Any]:
        """Convert finding to dictionary."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'category': self.category.value,
            'cwe_id': self.cwe_id,
            'cvss_score': self.cvss_score,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'column_number': self.column_number,
            'code_snippet': self.code_snippet,
            'evidence': self.evidence,
            'remediation': self.remediation,
            'references': self.references,
            'false_positive': self.false_positive,
            'verified': self.verified,
            'discovered_at': self.discovered_at.isoformat(),
            'tags': list(self.tags)
        }


@dataclass
class ScanConfiguration:
    """Configuration for vulnerability scans."""

    scan_type: str
    target: str
    depth: str = "normal"  # shallow, normal, deep
    include_dependencies: bool = True
    include_third_party: bool = False
    custom_rules: List[str] = field(default_factory=list)
    exclude_patterns: List[str] = field(default_factory=list)
    timeout: int = 300  # 5 minutes default
    max_file_size: int = 10 * 1024 * 1024  # 10MB
    enable_dynamic_analysis: bool = False


class EnhancedVulnerabilityScanner:
    """Enhanced vulnerability scanner with advanced analysis capabilities."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.findings: List[VulnerabilityFinding] = []
        self.scan_history: List[Dict[str, Any]] = []
        self.custom_rules: Dict[str, Any] = {}
        self.vulnerability_db: Dict[str, Any] = {}

        # Enhanced vulnerability patterns
        self.vulnerability_patterns = self._initialize_vulnerability_patterns()

        # Control flow analysis
        self.control_flow_cache = {}

        # Dynamic analysis capabilities
        self.dynamic_findings = []

        # Load vulnerability database
        self._load_vulnerability_database()

    def _initialize_vulnerability_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize comprehensive vulnerability patterns."""
        return {
            'cryptography': [
                {
                    'pattern': r'(?i)(md5|sha1)\s*\(',
                    'title': 'Weak Cryptographic Hash',
                    'description': 'Use of deprecated or weak cryptographic hash function',
                    'severity': VulnerabilitySeverity.HIGH,
                    'category': VulnerabilityCategory.CRYPTOGRAPHY,
                    'cwe_id': 'CWE-327',
                    'remediation': 'Use SHA-256 or higher for hashing operations'
                },
                {
                    'pattern': r'(?i)random\s*\.\s*(randint|choice|random)\s*\(',
                    'title': 'Weak Random Number Generation',
                    'description': 'Use of non-cryptographically secure random number generator',
                    'severity': VulnerabilitySeverity.MEDIUM,
                    'category': VulnerabilityCategory.CRYPTOGRAPHY,
                    'cwe_id': 'CWE-338',
                    'remediation': 'Use cryptographically secure random number generators'
                },
                {
                    'pattern': r'(?i)(des|rc4|blowfish)\s*\(',
                    'title': 'Deprecated Encryption Algorithm',
                    'description': 'Use of deprecated or broken encryption algorithm',
                    'severity': VulnerabilitySeverity.HIGH,
                    'category': VulnerabilityCategory.CRYPTOGRAPHY,
                    'cwe_id': 'CWE-327',
                    'remediation': 'Use AES-256-GCM or other modern encryption algorithms'
                }
            ],
            'authentication': [
                {
                    'pattern': r'(?i)password\s*==\s*["\'][^"\']+["\']',
                    'title': 'Hardcoded Password',
                    'description': 'Hardcoded password detected in source code',
                    'severity': VulnerabilitySeverity.CRITICAL,
                    'category': VulnerabilityCategory.AUTHENTICATION,
                    'cwe_id': 'CWE-798',
                    'remediation': 'Use environment variables or secure credential management'
                },
                {
                    'pattern': r'(?i)session\s*id.*\+.*user',
                    'title': 'Predictable Session ID',
                    'description': 'Session ID generation may be predictable',
                    'severity': VulnerabilitySeverity.MEDIUM,
                    'category': VulnerabilityCategory.AUTHENTICATION,
                    'cwe_id': 'CWE-340',
                    'remediation': 'Use cryptographically secure session ID generation'
                }
            ],
            'input_validation': [
                {
                    'pattern': r'(?i)eval\s*\(\s*.*\+',
                    'title': 'Code Injection',
                    'description': 'Potential code injection through eval() function',
                    'severity': VulnerabilitySeverity.CRITICAL,
                    'category': VulnerabilityCategory.INPUT_VALIDATION,
                    'cwe_id': 'CWE-95',
                    'remediation': 'Avoid using eval() with user input, use safe alternatives'
                },
                {
                    'pattern': r'(?i)exec\s*\(\s*.*\+',
                    'title': 'Command Injection',
                    'description': 'Potential command injection vulnerability',
                    'severity': VulnerabilitySeverity.CRITICAL,
                    'category': VulnerabilityCategory.INPUT_VALIDATION,
                    'cwe_id': 'CWE-78',
                    'remediation': 'Use subprocess with argument lists instead of shell commands'
                }
            ],
            'network': [
                {
                    'pattern': r'(?i)bind\s*\(\s*["\']0\.0\.0\.0["\']',
                    'title': 'Binding to All Interfaces',
                    'description': 'Service binding to all network interfaces (0.0.0.0)',
                    'severity': VulnerabilitySeverity.MEDIUM,
                    'category': VulnerabilityCategory.NETWORK,
                    'cwe_id': 'CWE-668',
                    'remediation': 'Bind to specific interface or use firewall rules'
                },
                {
                    'pattern': r'(?i)ssl_version.*sslv',
                    'title': 'Deprecated SSL/TLS Version',
                    'description': 'Use of deprecated SSL/TLS protocol version',
                    'severity': VulnerabilitySeverity.HIGH,
                    'category': VulnerabilityCategory.NETWORK,
                    'cwe_id': 'CWE-326',
                    'remediation': 'Use TLS 1.2 or higher, disable deprecated versions'
                }
            ],
            'configuration': [
                {
                    'pattern': r'(?i)debug\s*=\s*[Tt]rue',
                    'title': 'Debug Mode Enabled',
                    'description': 'Debug mode enabled in configuration',
                    'severity': VulnerabilitySeverity.MEDIUM,
                    'category': VulnerabilityCategory.CONFIGURATION,
                    'cwe_id': 'CWE-489',
                    'remediation': 'Disable debug mode in production environment'
                },
                {
                    'pattern': r'(?i)secret_key\s*=\s*["\'][^"\']+["\']',
                    'title': 'Hardcoded Secret Key',
                    'description': 'Hardcoded secret key in configuration',
                    'severity': VulnerabilitySeverity.HIGH,
                    'category': VulnerabilityCategory.CONFIGURATION,
                    'cwe_id': 'CWE-798',
                    'remediation': 'Use environment variables for secret keys'
                }
            ]
        }

    def _load_vulnerability_database(self):
        """Load vulnerability database for enhanced detection."""
        # In production, this would load from CVE databases, etc.
        self.vulnerability_db = {
            'known_vulnerabilities': {},
            'dependency_vulnerabilities': {},
            'signature_patterns': {}
        }

    async def scan_codebase(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform comprehensive codebase vulnerability scan."""
        self.logger.info(f"Starting enhanced vulnerability scan of {config.target}")

        findings = []
        start_time = datetime.now()

        try:
            # Static analysis
            static_findings = await self._perform_static_analysis(config)
            findings.extend(static_findings)

            # Control flow analysis
            if config.depth in ['normal', 'deep']:
                control_flow_findings = await self._perform_control_flow_analysis(config)
                findings.extend(control_flow_findings)

            # Dependency analysis
            if config.include_dependencies:
                dep_findings = await self._scan_dependencies(config)
                findings.extend(dep_findings)

            # Configuration analysis
            config_findings = await self._scan_configuration(config)
            findings.extend(config_findings)

            # Dynamic analysis (if enabled)
            if config.enable_dynamic_analysis:
                dynamic_findings = await self._perform_dynamic_analysis(config)
                findings.extend(dynamic_findings)

        except Exception as e:
            self.logger.error(f"Error during vulnerability scan: {e}")
            findings.append(VulnerabilityFinding(
                id=f"scan_error_{int(time.time())}",
                title="Scan Error",
                description=f"Vulnerability scan failed: {str(e)}",
                severity=VulnerabilitySeverity.INFORMATIONAL,
                category=VulnerabilityCategory.CONFIGURATION
            ))

        # Record scan in history
        scan_record = {
            'timestamp': start_time.isoformat(),
            'target': config.target,
            'scan_type': config.scan_type,
            'findings_count': len(findings),
            'duration': (datetime.now() - start_time).total_seconds(),
            'configuration': config.__dict__
        }
        self.scan_history.append(scan_record)

        self.logger.info(f"Scan completed. Found {len(findings)} vulnerabilities")
        return findings

    async def _perform_static_analysis(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform advanced static code analysis."""
        findings = []

        # Walk through codebase
        for root, dirs, files in os.walk(config.target):
            # Skip unwanted directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules', '.git']]

            for file in files:
                file_path = os.path.join(root, file)

                # Check file size
                if os.path.getsize(file_path) > config.max_file_size:
                    continue

                # Check exclude patterns
                if any(re.search(pattern, file_path) for pattern in config.exclude_patterns):
                    continue

                # Analyze based on file type
                if file.endswith('.py'):
                    file_findings = await self._analyze_python_file(file_path, config)
                    findings.extend(file_findings)
                elif file.endswith(('.js', '.ts')):
                    file_findings = await self._analyze_javascript_file(file_path, config)
                    findings.extend(file_findings)
                elif file.endswith(('.json', '.yaml', '.yml')):
                    file_findings = await self._analyze_config_file(file_path, config)
                    findings.extend(file_findings)

        return findings

    async def _analyze_python_file(self, file_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze Python file for vulnerabilities."""
        findings = []

        try:
            async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                content = await f.read()

            lines = content.split('\n')

            # Pattern-based analysis
            for category, patterns in self.vulnerability_patterns.items():
                for pattern_info in patterns:
                    for match in re.finditer(pattern_info['pattern'], content, re.MULTILINE | re.IGNORECASE):
                        line_number = content[:match.start()].count('\n') + 1

                        finding = VulnerabilityFinding(
                            id=f"py_{category}_{hash(match.group())}_{int(time.time())}",
                            title=pattern_info['title'],
                            description=pattern_info['description'],
                            severity=pattern_info['severity'],
                            category=pattern_info['category'],
                            cwe_id=pattern_info['cwe_id'],
                            file_path=file_path,
                            line_number=line_number,
                            code_snippet=self._get_code_snippet(lines, line_number),
                            evidence=[match.group().strip()],
                            remediation=pattern_info['remediation']
                        )

                        # Check for false positives
                        if not self._is_false_positive(finding, content):
                            findings.append(finding)

            # AST-based analysis
            ast_findings = await self._analyze_python_ast(file_path, content)
            findings.extend(ast_findings)

            # Import analysis
            import_findings = await self._analyze_imports(file_path, content)
            findings.extend(import_findings)

        except Exception as e:
            self.logger.error(f"Error analyzing Python file {file_path}: {e}")

        return findings

    async def _analyze_python_ast(self, file_path: str, content: str) -> List[VulnerabilityFinding]:
        """Analyze Python AST for security issues."""
        findings = []

        try:
            tree = ast.parse(content)

            class SecurityVisitor(ast.NodeVisitor):
                def __init__(self, scanner, file_path):
                    self.scanner = scanner
                    self.file_path = file_path
                    self.findings = []

                def visit_Call(self, node):
                    """Check function calls for security issues."""
                    if isinstance(node.func, ast.Name):
                        func_name = node.func.id

                        # Dangerous function calls
                        dangerous_functions = {
                            'eval': ('CWE-95', VulnerabilitySeverity.CRITICAL, 'Code Injection'),
                            'exec': ('CWE-95', VulnerabilitySeverity.CRITICAL, 'Code Injection'),
                            '__import__': ('CWE-830', VulnerabilitySeverity.HIGH, 'Dynamic Import'),
                            'input': ('CWE-117', VulnerabilitySeverity.MEDIUM, 'Untrusted Input')
                        }

                        if func_name in dangerous_functions:
                            cwe_id, severity, title = dangerous_functions[func_name]

                            # Check if arguments contain variables (potential injection)
                            for arg in node.args:
                                if isinstance(arg, ast.Name):
                                    finding = VulnerabilityFinding(
                                        id=f"ast_{func_name}_{ast.get_source_segment(content, node)}",
                                        title=f"Dangerous Function Call: {title}",
                                        description=f"Use of {func_name}() may lead to {title.lower()}",
                                        severity=severity,
                                        category=VulnerabilityCategory.INPUT_VALIDATION,
                                        cwe_id=cwe_id,
                                        file_path=self.file_path,
                                        line_number=node.lineno,
                                        code_snippet=ast.get_source_segment(content, node)
                                    )
                                    self.findings.append(finding)

                    self.generic_visit(node)

                def visit_Import(self, node):
                    """Check imports for potentially vulnerable modules."""
                    for alias in node.names:
                        module_name = alias.name

                        # Check for deprecated or vulnerable modules
                        risky_modules = {
                            'pickle': ('CWE-502', VulnerabilitySeverity.HIGH, 'Insecure Deserialization'),
                            'subprocess': ('CWE-78', VulnerabilitySeverity.HIGH, 'Command Injection Risk')
                        }

                        if module_name in risky_modules:
                            cwe_id, severity, title = risky_modules[module_name]

                            finding = VulnerabilityFinding(
                                id=f"import_{module_name}_{node.lineno}",
                                title=f"Risky Module Import: {title}",
                                description=f"Import of {module_name} module presents {title.lower()} risk",
                                severity=severity,
                                category=VulnerabilityCategory.INPUT_VALIDATION,
                                cwe_id=cwe_id,
                                file_path=self.file_path,
                                line_number=node.lineno,
                                code_snippet=ast.get_source_segment(content, node)
                            )
                            self.findings.append(finding)

                    self.generic_visit(node)

            visitor = SecurityVisitor(self, file_path)
            visitor.visit(tree)
            findings.extend(visitor.findings)

        except SyntaxError as e:
            findings.append(VulnerabilityFinding(
                id=f"syntax_error_{hash(file_path)}",
                title="Syntax Error",
                description=f"Python syntax error may indicate obfuscated malicious code: {e}",
                severity=VulnerabilitySeverity.MEDIUM,
                category=VulnerabilityCategory.INPUT_VALIDATION,
                file_path=file_path,
                line_number=e.lineno if hasattr(e, 'lineno') else None
            ))

        return findings

    async def _analyze_imports(self, file_path: str, content: str) -> List[VulnerabilityFinding]:
        """Analyze import statements for security issues."""
        findings = []

        # Check for imports of known vulnerable libraries
        vulnerable_imports = {
            'requests': {'min_version': '2.25.0', 'cve': 'CVE-2021-3156'},
            'flask': {'min_version': '2.0.0', 'cve': 'CVE-2020-28493'},
            'django': {'min_version': '3.2.0', 'cve': 'CVE-2021-35042'}
        }

        for lib, info in vulnerable_imports.items():
            if f'import {lib}' in content or f'from {lib}' in content:
                findings.append(VulnerabilityFinding(
                    id=f"import_{lib}_{hash(file_path)}",
                    title=f"Potentially Vulnerable Import: {lib}",
                    description=f"Import of {lib} library which may have known vulnerabilities",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.DEPENDENCY,
                    cwe_id='CWE-1104',
                    file_path=file_path,
                    evidence=[f"Import statement found for {lib}"],
                    remediation=f"Ensure {lib} is updated to version {info['min_version']} or higher"
                ))

        return findings

    async def _perform_control_flow_analysis(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform control flow analysis for advanced vulnerability detection."""
        findings = []

        # This would implement more sophisticated analysis
        # For now, return empty list as placeholder
        return findings

    async def _scan_dependencies(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Scan dependencies for known vulnerabilities."""
        findings = []

        # Check requirements.txt
        req_file = Path(config.target) / 'requirements.txt'
        if req_file.exists():
            dep_findings = await self._analyze_requirements_file(str(req_file))
            findings.extend(dep_findings)

        # Check package.json for Node.js projects
        package_file = Path(config.target) / 'package.json'
        if package_file.exists():
            dep_findings = await self._analyze_package_file(str(package_file))
            findings.extend(dep_findings)

        return findings

    async def _analyze_requirements_file(self, file_path: str) -> List[VulnerabilityFinding]:
        """Analyze Python requirements file for vulnerabilities."""
        findings = []

        try:
            async with aiofiles.open(file_path, 'r') as f:
                content = await f.read()

            lines = content.split('\n')

            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Parse package specification
                if '==' in line:
                    package, version = line.split('==', 1)
                    package = package.strip().lower()
                    version = version.strip()

                    # Check against known vulnerabilities
                    if package in self.vulnerability_db.get('dependency_vulnerabilities', {}):
                        vuln_info = self.vulnerability_db['dependency_vulnerabilities'][package]

                        if self._is_vulnerable_version(version, vuln_info['affected_versions']):
                            findings.append(VulnerabilityFinding(
                                id=f"dep_{package}_{hash(line)}",
                                title=f"Vulnerable Dependency: {package}",
                                description=f"Dependency {package}=={version} has known vulnerabilities",
                                severity=VulnerabilitySeverity.HIGH,
                                category=VulnerabilityCategory.DEPENDENCY,
                                cwe_id='CWE-1104',
                                file_path=file_path,
                                line_number=line_num,
                                evidence=[line, f"CVE: {vuln_info.get('cve', 'Unknown')}"],
                                remediation=f"Update {package} to version {vuln_info.get('fixed_version', 'latest')}"
                            ))

        except Exception as e:
            self.logger.error(f"Error analyzing requirements file {file_path}: {e}")

        return findings

    async def _analyze_package_file(self, file_path: str) -> List[VulnerabilityFinding]:
        """Analyze Node.js package.json file for vulnerabilities."""
        findings = []

        try:
            async with aiofiles.open(file_path, 'r') as f:
                content = await f.read()

            package_data = json.loads(content)

            # Check dependencies
            for section in ['dependencies', 'devDependencies']:
                if section in package_data:
                    for package, version in package_data[section].items():
                        # Check for known vulnerabilities
                        if package in self.vulnerability_db.get('dependency_vulnerabilities', {}):
                            vuln_info = self.vulnerability_db['dependency_vulnerabilities'][package]

                            if self._is_vulnerable_version(version, vuln_info['affected_versions']):
                                findings.append(VulnerabilityFinding(
                                    id=f"npm_{package}_{hash(f'{package}{version}')}",
                                    title=f"Vulnerable NPM Package: {package}",
                                    description=f"NPM package {package}@{version} has known vulnerabilities",
                                    severity=VulnerabilitySeverity.HIGH,
                                    category=VulnerabilityCategory.DEPENDENCY,
                                    file_path=file_path,
                                    evidence=[f"{package}@{version}", f"CVE: {vuln_info.get('cve', 'Unknown')}"],
                                    remediation=f"Update {package} to version {vuln_info.get('fixed_version', 'latest')}"
                                ))

        except Exception as e:
            self.logger.error(f"Error analyzing package file {file_path}: {e}")

        return findings

    async def _scan_configuration(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Scan configuration files for security issues."""
        findings = []

        # Common configuration files to check
        config_files = [
            'config.json', 'config.yaml', 'config.yml',
            'settings.json', 'settings.yaml', 'settings.yml',
            '.env', '.env.local', '.env.production'
        ]

        for config_file in config_files:
            config_path = Path(config.target) / config_file
            if config_path.exists():
                file_findings = await self._analyze_config_file(str(config_path), config)
                findings.extend(file_findings)

        return findings

    async def _analyze_config_file(self, file_path: str, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Analyze configuration file for security issues."""
        findings = []

        try:
            async with aiofiles.open(file_path, 'r') as f:
                content = await f.read()

            # Check for sensitive information in config
            sensitive_patterns = [
                (r'(?i)(password|passwd|pwd)\s*[:=]\s*["\'][^"\']+["\']', 'Hardcoded Password'),
                (r'(?i)(api_key|apikey|secret)\s*[:=]\s*["\'][^"\']+["\']', 'Hardcoded API Key'),
                (r'(?i)(private_key|privkey)\s*[:=]\s*["\'][^"\']+["\']', 'Hardcoded Private Key'),
                (r'(?i)debug\s*[:=]\s*(true|1)', 'Debug Mode Enabled')
            ]

            for pattern, title in sensitive_patterns:
                for match in re.finditer(pattern, content, re.IGNORECASE):
                    findings.append(VulnerabilityFinding(
                        id=f"config_{hash(match.group())}_{int(time.time())}",
                        title=title,
                        description=f"Potentially sensitive information found in configuration file",
                        severity=VulnerabilitySeverity.HIGH,
                        category=VulnerabilityCategory.CONFIGURATION,
                        cwe_id='CWE-798',
                        file_path=file_path,
                        evidence=[match.group().strip()],
                        remediation="Remove sensitive information from configuration files"
                    ))

        except Exception as e:
            self.logger.error(f"Error analyzing config file {file_path}: {e}")

        return findings

    async def _perform_dynamic_analysis(self, config: ScanConfiguration) -> List[VulnerabilityFinding]:
        """Perform dynamic application security testing."""
        findings = []

        # This would implement runtime analysis
        # For now, return empty list as placeholder
        return findings

    def _get_code_snippet(self, lines: List[str], line_number: int, context: int = 3) -> str:
        """Get code snippet around a line number."""
        start = max(0, line_number - context - 1)
        end = min(len(lines), line_number + context)

        snippet_lines = []
        for i in range(start, end):
            marker = '>>> ' if i == line_number - 1 else '    '
            snippet_lines.append(f"{i+1:4d}: {marker}{lines[i]}")

        return '\n'.join(snippet_lines)

    def _is_false_positive(self, finding: VulnerabilityFinding, content: str) -> bool:
        """Check if a finding is likely a false positive."""
        # Skip test files
        if finding.file_path and any(test_indicator in finding.file_path.lower()
                                   for test_indicator in ['test', 'spec', 'example']):
            return True

        # Skip comments
        if finding.line_number and finding.code_snippet:
            lines = finding.code_snippet.split('\n')
            for line in lines:
                if line.strip().startswith('#') or line.strip().startswith('//'):
                    return True

        return False

    def _is_vulnerable_version(self, version: str, affected_versions: str) -> bool:
        """Check if a version is affected by a vulnerability."""
        # Simple version comparison - in production would use proper semver
        if '<' in affected_versions:
            return version < affected_versions[1:]
        elif '<=' in affected_versions:
            return version <= affected_versions[2:]
        elif '==' in affected_versions:
            return version == affected_versions[2:]

        return False

    async def scan_network_services(self, target: str, ports: List[int] = None) -> List[VulnerabilityFinding]:
        """Scan network services for vulnerabilities."""
        findings = []

        if ports is None:
            ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 8080, 8443]

        # Port scanning
        open_ports = await self._scan_ports_async(target, ports)

        # Service analysis
        for port in open_ports:
            service_findings = await self._analyze_service(target, port)
            findings.extend(service_findings)

        return findings

    async def _scan_ports_async(self, target: str, ports: List[int]) -> List[int]:
        """Asynchronously scan ports for open services."""
        async def check_port(port):
            try:
                connector = asyncio.open_connection(target, port)
                reader, writer = await asyncio.wait_for(connector, timeout=2.0)
                writer.close()
                await writer.wait_closed()
                return port
            except:
                return None

        tasks = [check_port(port) for port in ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        return [port for port in results if port is not None]

    async def _analyze_service(self, target: str, port: int) -> List[VulnerabilityFinding]:
        """Analyze a network service for vulnerabilities."""
        findings = []

        try:
            # Get service banner
            banner = await self._get_service_banner(target, port)

            if banner:
                # Check for known vulnerable services
                vuln_findings = await self._check_service_vulnerabilities(target, port, banner)
                findings.extend(vuln_findings)

                # Check SSL/TLS configuration
                if port in [443, 8443, 993, 995]:
                    ssl_findings = await self._check_ssl_configuration(target, port)
                    findings.extend(ssl_findings)

        except Exception as e:
            self.logger.error(f"Error analyzing service {target}:{port}: {e}")

        return findings

    async def _get_service_banner(self, target: str, port: int) -> Optional[str]:
        """Get service banner for identification."""
        try:
            reader, writer = await asyncio.open_connection(target, port)

            # Send basic probe
            if port == 80:
                writer.write(b'HEAD / HTTP/1.0\r\n\r\n')
            elif port == 25:
                # SMTP sends banner automatically
                pass
            else:
                writer.write(b'\r\n')

            banner = await asyncio.wait_for(reader.read(1024), timeout=3.0)
            writer.close()
            await writer.wait_closed()

            return banner.decode('utf-8', errors='ignore')

        except:
            return None

    async def _check_service_vulnerabilities(self, target: str, port: int, banner: str) -> List[VulnerabilityFinding]:
        """Check service banner for known vulnerabilities."""
        findings = []

        # Check for outdated service versions
        version_patterns = [
            (r'nginx/(\d+\.\d+\.\d+)', 'nginx'),
            (r'apache/(\d+\.\d+\.\d+)', 'apache'),
            (r'openssh[/-](\d+\.\d+)', 'openssh'),
            (r'mysql[/-](\d+\.\d+\.\d+)', 'mysql')
        ]

        for pattern, service in version_patterns:
            match = re.search(pattern, banner, re.IGNORECASE)
            if match:
                version = match.group(1)

                # Check if version is outdated (simplified check)
                if self._is_outdated_service_version(service, version):
                    findings.append(VulnerabilityFinding(
                        id=f"service_{service}_{port}_{hash(f'{target}{port}{version}')}",
                        title=f"Outdated Service Version: {service}",
                        description=f"{service} version {version} may be outdated and vulnerable",
                        severity=VulnerabilitySeverity.MEDIUM,
                        category=VulnerabilityCategory.NETWORK,
                        file_path=None,
                        evidence=[banner.strip(), f"Version: {version}"],
                        remediation=f"Update {service} to the latest stable version"
                    ))

        return findings

    async def _check_ssl_configuration(self, target: str, port: int) -> List[VulnerabilityFinding]:
        """Check SSL/TLS configuration for vulnerabilities."""
        findings = []

        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            # Connect with SSL
            reader, writer = await asyncio.open_connection(target, port, ssl=context)

            # Get certificate
            cert = context.get_ca_certs()  # This would need proper implementation

            writer.close()
            await writer.wait_closed()

            # Check for weak protocols and ciphers
            # This is a simplified check - production would use proper SSL testing

        except Exception as e:
            findings.append(VulnerabilityFinding(
                id=f"ssl_error_{hash(f'{target}{port}')}",
                title="SSL/TLS Configuration Issue",
                description=f"Unable to establish secure SSL/TLS connection: {str(e)}",
                severity=VulnerabilitySeverity.MEDIUM,
                category=VulnerabilityCategory.NETWORK
            ))

        return findings

    def _is_outdated_service_version(self, service: str, version: str) -> bool:
        """Check if service version is outdated."""
        # Simplified version checking - production would use comprehensive database
        outdated_versions = {
            'nginx': '1.20.0',
            'apache': '2.4.48',
            'openssh': '8.0',
            'mysql': '8.0'
        }

        if service in outdated_versions:
            return version < outdated_versions[service]

        return False

    def generate_scan_report(self, findings: List[VulnerabilityFinding],
                           format: str = 'json') -> str:
        """Generate comprehensive scan report."""
        if format == 'json':
            report_data = {
                'scan_metadata': {
                    'timestamp': datetime.now().isoformat(),
                    'scanner_version': '2.0',
                    'total_findings': len(findings)
                },
                'summary': self._generate_summary(findings),
                'findings': [finding.to_dict() for finding in findings],
                'recommendations': self._generate_recommendations(findings)
            }
            return json.dumps(report_data, indent=2)

        elif format == 'html':
            return self._generate_html_report(findings)

        return ""

    def _generate_summary(self, findings: List[VulnerabilityFinding]) -> Dict[str, Any]:
        """Generate scan summary."""
        summary = {
            'total': len(findings),
            'by_severity': defaultdict(int),
            'by_category': defaultdict(int),
            'verified': 0,
            'false_positives': 0
        }

        for finding in findings:
            summary['by_severity'][finding.severity.value] += 1
            summary['by_category'][finding.category.value] += 1
            if finding.verified:
                summary['verified'] += 1
            if finding.false_positive:
                summary['false_positives'] += 1

        return dict(summary)

    def _generate_recommendations(self, findings: List[VulnerabilityFinding]) -> List[str]:
        """Generate remediation recommendations."""
        recommendations = []

        # Group findings by category
        by_category = defaultdict(list)
        for finding in findings:
            if not finding.false_positive:
                by_category[finding.category].append(finding)

        # Generate category-specific recommendations
        if by_category[VulnerabilityCategory.CRYPTOGRAPHY]:
            recommendations.append(
                "Review and update cryptographic implementations to use modern algorithms"
            )

        if by_category[VulnerabilityCategory.DEPENDENCY]:
            recommendations.append(
                "Update dependencies to latest secure versions and implement dependency scanning"
            )

        if by_category[VulnerabilityCategory.CONFIGURATION]:
            recommendations.append(
                "Remove sensitive information from configuration files and use environment variables"
            )

        return recommendations

    def _generate_html_report(self, findings: List[VulnerabilityFinding]) -> str:
        """Generate HTML scan report."""
        summary = self._generate_summary(findings)

        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Enhanced Vulnerability Scan Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #333; color: white; padding: 20px; }}
                .summary {{ background: #f0f0f0; padding: 20px; margin: 20px 0; }}
                .finding {{ border: 1px solid #ddd; padding: 15px; margin: 10px 0; }}
                .critical {{ border-left: 5px solid #ff0000; }}
                .high {{ border-left: 5px solid #ff9900; }}
                .medium {{ border-left: 5px solid #ffcc00; }}
                .low {{ border-left: 5px solid #00cc00; }}
                .info {{ border-left: 5px solid #0099ff; }}
                code {{ background: #f5f5f5; padding: 2px 5px; }}
                .stats {{ display: flex; gap: 20px; }}
                .stat {{ background: #e8e8e8; padding: 10px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Enhanced Vulnerability Scan Report</h1>
                <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>

            <div class="summary">
                <h2>Scan Summary</h2>
                <div class="stats">
                    <div class="stat">
                        <strong>Total Findings:</strong> {summary['total']}
                    </div>
                    <div class="stat">
                        <strong>Critical:</strong> {summary['by_severity']['critical']}
                    </div>
                    <div class="stat">
                        <strong>High:</strong> {summary['by_severity']['high']}
                    </div>
                    <div class="stat">
                        <strong>Medium:</strong> {summary['by_severity']['medium']}
                    </div>
                    <div class="stat">
                        <strong>Low:</strong> {summary['by_severity']['low']}
                    </div>
                </div>
            </div>

            <h2>Vulnerability Findings</h2>
        """

        # Sort findings by severity
        severity_order = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 3,
            VulnerabilitySeverity.INFORMATIONAL: 4
        }

        sorted_findings = sorted(
            [f for f in findings if not f.false_positive],
            key=lambda f: severity_order[f.severity]
        )

        for finding in sorted_findings:
            html += f"""
            <div class="finding {finding.severity.value}">
                <h3>{finding.title}</h3>
                <p><strong>Severity:</strong> {finding.severity.value.upper()}</p>
                <p><strong>Category:</strong> {finding.category.value}</p>
                <p><strong>Description:</strong> {finding.description}</p>
                {f"<p><strong>File:</strong> {finding.file_path}</p>" if finding.file_path else ""}
                {f"<p><strong>Line:</strong> {finding.line_number}</p>" if finding.line_number else ""}
                {f"<p><strong>CWE:</strong> {finding.cwe_id}</p>" if finding.cwe_id else ""}
                {f"<p><strong>Remediation:</strong> {finding.remediation}</p>" if finding.remediation else ""}
                {f"<pre><code>{finding.code_snippet}</code></pre>" if finding.code_snippet else ""}
            </div>
            """

        html += """
        </body>
        </html>
        """

        return html