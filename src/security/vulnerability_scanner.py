# Vulnerability Scanner
"""Automated vulnerability scanning and detection."""

import re
import os
import json
import socket
import requests
import asyncio
import logging
import threading
from typing import Dict, List, Any, Optional, Tuple, Set
from pathlib import Path
from datetime import datetime
import subprocess
import hashlib
import concurrent.futures

class VulnerabilityScanner:
    """Automated vulnerability scanner for continuous security validation."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scan_results = []
        self.running_scans = {}
        
        # Vulnerability patterns
        self.vuln_patterns = {
            'code': {
                # Code vulnerabilities
                'buffer_overflow': [
                    r'strcpy\s*\(',
                    r'strcat\s*\(',
                    r'sprintf\s*\(',
                    r'gets\s*\('
                ],
                'format_string': [
                    r'printf\s*\([^,]+\)',
                    r'fprintf\s*\([^,]+,[^,]+\)',
                    r'sprintf\s*\([^,]+,[^,]+\)'
                ],
                'race_condition': [
                    r'(?:open|access|stat)\s*\([^)]+\).*(?:open|access|stat)',
                    r'threading\.Thread.*shared'
                ],
                'memory_leak': [
                    r'malloc\s*\([^)]+\)(?!.*free)',
                    r'new\s+\w+(?!.*delete)'
                ],
                'null_deref': [
                    r'(?:if\s*\(\s*)?(\w+)\s*(?:!=|==)\s*(?:NULL|None|null).*\1\s*\.',
                    r'(\w+)\s*=\s*(?:NULL|None|null).*\1\s*\.'
                ]
            },
            'web': {
                # Web vulnerabilities
                'sql_injection': [
                    r'SELECT.*FROM.*WHERE.*\+',
                    r'INSERT\s+INTO.*VALUES\s*\([^)]*\+',
                    r'UPDATE.*SET.*WHERE.*\+',
                    r'DELETE\s+FROM.*WHERE.*\+'
                ],
                'xss': [
                    r'document\.write\s*\([^)]*\+',
                    r'innerHTML\s*=\s*[^;]*\+',
                    r'eval\s*\([^)]*\+',
                    r'setTimeout\s*\([^)]*\+'
                ],
                'xxe': [
                    r'XMLReader.*FEATURE_SECURE_PROCESSING.*false',
                    r'DocumentBuilder.*setExpandEntityReferences\s*\(\s*true',
                    r'SAXParser.*setFeature.*external-general-entities.*true'
                ],
                'open_redirect': [
                    r'redirect\s*\([^)]*request\.',
                    r'window\.location\s*=\s*[^;]*\+',
                    r'header\s*\(\s*["\']Location:.*\+'
                ],
                'ssrf': [
                    r'requests\.\w+\s*\([^)]*user.*input',
                    r'urllib.*urlopen\s*\([^)]*request\.',
                    r'curl_exec\s*\([^)]*\$_(?:GET|POST)'
                ]
            },
            'crypto': {
                # Cryptographic vulnerabilities
                'weak_hash': [
                    r'hashlib\.(?:md5|sha1)\s*\(',
                    r'MD5|SHA1|SHA-1',
                    r'(?:md5|sha1)_(?:hex|file)'
                ],
                'weak_prng': [
                    r'random\.(?:random|randint|choice)\s*\(',
                    r'Math\.random\s*\(',
                    r'rand\s*\(\s*\)'
                ],
                'hardcoded_key': [
                    r'(?:key|secret|password)\s*=\s*["\'][a-fA-F0-9]{16,}["\']',
                    r'AES\.new\s*\(["\'][^"\']+["\']',
                    r'private_key\s*=\s*["\'][^"\']+["\']'
                ],
                'insecure_cipher': [
                    r'DES\.|DESede\.|RC4\.|RC2\.',
                    r'Cipher\.getInstance\s*\(["\'](?:DES|RC4|RC2)',
                    r'(?:des|rc4|rc2)_(?:encrypt|decrypt)'
                ],
                'no_integrity': [
                    r'AES.*ECB',
                    r'Cipher\.getInstance\s*\(["\']AES["\']',
                    r'encrypt.*(?!.*(?:hmac|tag|authenticate))'
                ]
            },
            'network': {
                # Network vulnerabilities
                'plaintext_protocol': [
                    r'http://',
                    r'ftp://',
                    r'telnet://',
                    r'ldap://'
                ],
                'weak_tls': [
                    r'SSLv2|SSLv3|TLSv1\.0',
                    r'ssl_protocols.*(?:SSLv2|SSLv3|TLSv1\.0)',
                    r'PROTOCOL_(?:SSLv2|SSLv3|TLSv1)'
                ],
                'no_cert_validation': [
                    r'verify\s*=\s*False',
                    r'NODE_TLS_REJECT_UNAUTHORIZED\s*=\s*0',
                    r'InsecureRequestWarning'
                ],
                'exposed_service': [
                    r'bind\s*\([^)]*0\.0\.0\.0',
                    r'listen\s*\([^)]*\*',
                    r'server\.listen\s*\([^)]*0\.0\.0\.0'
                ]
            }
        }
        
        # OWASP Top 10 mapping
        self.owasp_mapping = {
            'sql_injection': 'A03:2021 – Injection',
            'xss': 'A03:2021 – Injection',
            'weak_auth': 'A07:2021 – Identification and Authentication Failures',
            'xxe': 'A05:2021 – Security Misconfiguration',
            'access_control': 'A01:2021 – Broken Access Control',
            'security_misconfig': 'A05:2021 – Security Misconfiguration',
            'sensitive_data': 'A02:2021 – Cryptographic Failures',
            'components': 'A06:2021 – Vulnerable and Outdated Components',
            'logging': 'A09:2021 – Security Logging and Monitoring Failures',
            'ssrf': 'A10:2021 – Server-Side Request Forgery'
        }
        
    async def scan_codebase(self, directory: str) -> List[Dict[str, Any]]:
        """Scan codebase for vulnerabilities."""
        self.logger.info(f"Starting codebase scan of {directory}")
        vulnerabilities = []
        
        # Scan all files
        for root, dirs, files in os.walk(directory):
            # Skip hidden and cache directories
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']
            
            for file in files:
                if file.endswith(('.py', '.js', '.java', '.c', '.cpp', '.php')):
                    file_path = os.path.join(root, file)
                    file_vulns = await self._scan_file(file_path)
                    vulnerabilities.extend(file_vulns)
                    
        return vulnerabilities
        
    async def _scan_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Scan individual file for vulnerabilities."""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
                
            # Check each vulnerability category
            for category, patterns_dict in self.vuln_patterns.items():
                for vuln_type, patterns in patterns_dict.items():
                    for pattern in patterns:
                        for match in re.finditer(pattern, content, re.IGNORECASE):
                            line_num = content[:match.start()].count('\n') + 1
                            
                            vuln = {
                                'file': file_path,
                                'line': line_num,
                                'category': category,
                                'type': vuln_type,
                                'severity': self._calculate_severity(vuln_type),
                                'description': f"{vuln_type.replace('_', ' ').title()} vulnerability detected",
                                'code_snippet': self._get_code_context(lines, line_num),
                                'pattern_matched': pattern,
                                'confidence': self._calculate_confidence(vuln_type, match.group()),
                                'owasp': self.owasp_mapping.get(vuln_type, 'N/A'),
                                'timestamp': datetime.now().isoformat()
                            }
                            
                            vulnerabilities.append(vuln)
                            
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
            
        return vulnerabilities
        
    def scan_network(self, target: str, ports: List[int] = None) -> List[Dict[str, Any]]:
        """Scan network services for vulnerabilities."""
        self.logger.info(f"Starting network scan of {target}")
        vulnerabilities = []
        
        if ports is None:
            ports = [21, 22, 23, 25, 80, 443, 3306, 5432, 6379, 8080, 8443, 9200]
            
        # Port scanning
        open_ports = self._scan_ports(target, ports)
        
        # Service detection and vulnerability checks
        for port in open_ports:
            service_vulns = self._check_service_vulnerabilities(target, port)
            vulnerabilities.extend(service_vulns)
            
        # SSL/TLS checks
        if 443 in open_ports or 8443 in open_ports:
            ssl_vulns = self._check_ssl_vulnerabilities(target)
            vulnerabilities.extend(ssl_vulns)
            
        return vulnerabilities
        
    def _scan_ports(self, target: str, ports: List[int]) -> List[int]:
        """Scan for open ports."""
        open_ports = []
        
        def check_port(port):
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((target, port))
            sock.close()
            return port if result == 0 else None
            
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            results = executor.map(check_port, ports)
            open_ports = [port for port in results if port is not None]
            
        return open_ports
        
    def _check_service_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Check for service-specific vulnerabilities."""
        vulnerabilities = []
        
        # Service fingerprinting
        service = self._identify_service(target, port)
        
        # Check for default credentials
        if self._has_default_credentials(target, port, service):
            vulnerabilities.append({
                'type': 'default_credentials',
                'severity': 'critical',
                'target': f"{target}:{port}",
                'service': service,
                'description': 'Service is using default credentials',
                'remediation': 'Change default credentials immediately'
            })
            
        # Check for outdated versions
        version = self._get_service_version(target, port, service)
        if version and self._is_outdated_version(service, version):
            vulnerabilities.append({
                'type': 'outdated_software',
                'severity': 'high',
                'target': f"{target}:{port}",
                'service': service,
                'version': version,
                'description': 'Service is running an outdated version with known vulnerabilities',
                'remediation': 'Update to the latest stable version'
            })
            
        return vulnerabilities
        
    def _check_ssl_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Check for SSL/TLS vulnerabilities."""
        vulnerabilities = []
        
        # Check supported protocols
        weak_protocols = self._check_weak_protocols(target)
        if weak_protocols:
            vulnerabilities.append({
                'type': 'weak_tls_protocol',
                'severity': 'high',
                'target': target,
                'protocols': weak_protocols,
                'description': 'Server supports weak TLS protocols',
                'remediation': 'Disable SSLv2, SSLv3, and TLS 1.0'
            })
            
        # Check cipher suites
        weak_ciphers = self._check_weak_ciphers(target)
        if weak_ciphers:
            vulnerabilities.append({
                'type': 'weak_cipher_suite',
                'severity': 'medium',
                'target': target,
                'ciphers': weak_ciphers,
                'description': 'Server supports weak cipher suites',
                'remediation': 'Disable weak ciphers and use only strong cipher suites'
            })
            
        # Check certificate
        cert_issues = self._check_certificate(target)
        vulnerabilities.extend(cert_issues)
        
        return vulnerabilities
        
    def scan_dependencies(self, requirements_file: str = 'requirements.txt') -> List[Dict[str, Any]]:
        """Scan dependencies for known vulnerabilities."""
        self.logger.info(f"Scanning dependencies from {requirements_file}")
        vulnerabilities = []
        
        if not os.path.exists(requirements_file):
            return vulnerabilities
            
        # Parse requirements
        dependencies = self._parse_requirements(requirements_file)
        
        # Check each dependency
        for dep_name, dep_version in dependencies.items():
            dep_vulns = self._check_dependency_vulnerabilities(dep_name, dep_version)
            vulnerabilities.extend(dep_vulns)
            
        return vulnerabilities
        
    def _parse_requirements(self, file_path: str) -> Dict[str, str]:
        """Parse requirements file."""
        dependencies = {}
        
        with open(file_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    # Parse dependency and version
                    if '==' in line:
                        name, version = line.split('==')
                        dependencies[name.strip()] = version.strip()
                    elif '>=' in line:
                        name, version = line.split('>=')
                        dependencies[name.strip()] = f">={version.strip()}"
                    else:
                        dependencies[line] = '*'
                        
        return dependencies
        
    def _check_dependency_vulnerabilities(self, name: str, version: str) -> List[Dict[str, Any]]:
        """Check dependency for known vulnerabilities."""
        vulnerabilities = []
        
        # This would normally query vulnerability databases
        # For demo, checking against known vulnerable versions
        vulnerable_packages = {
            'requests': {'<2.20.0': 'CVE-2018-18074'},
            'django': {'<2.2.24': 'CVE-2021-35042'},
            'flask': {'<1.0': 'CVE-2018-1000656'},
            'pyyaml': {'<5.4': 'CVE-2020-14343'},
            'urllib3': {'<1.24.2': 'CVE-2019-11324'}
        }
        
        if name.lower() in vulnerable_packages:
            for vuln_version, cve in vulnerable_packages[name.lower()].items():
                if self._is_vulnerable_version(version, vuln_version):
                    vulnerabilities.append({
                        'type': 'vulnerable_dependency',
                        'severity': 'high',
                        'package': name,
                        'installed_version': version,
                        'vulnerable_versions': vuln_version,
                        'cve': cve,
                        'description': f'{name} {version} has known security vulnerabilities',
                        'remediation': f'Update {name} to the latest version'
                    })
                    
        return vulnerabilities
        
    def continuous_scan(self, targets: Dict[str, Any], interval: int = 3600):
        """Run continuous vulnerability scanning."""
        self.logger.info("Starting continuous vulnerability scanning")
        
        def scan_loop():
            while True:
                try:
                    # Run all scans
                    all_vulnerabilities = []
                    
                    # Code scan
                    if 'codebase' in targets:
                        code_vulns = asyncio.run(self.scan_codebase(targets['codebase']))
                        all_vulnerabilities.extend(code_vulns)
                        
                    # Network scan
                    if 'network' in targets:
                        for target in targets['network']:
                            net_vulns = self.scan_network(target)
                            all_vulnerabilities.extend(net_vulns)
                            
                    # Dependency scan
                    if 'dependencies' in targets:
                        dep_vulns = self.scan_dependencies(targets['dependencies'])
                        all_vulnerabilities.extend(dep_vulns)
                        
                    # Store results
                    self.scan_results.append({
                        'timestamp': datetime.now().isoformat(),
                        'vulnerabilities': all_vulnerabilities,
                        'summary': self._generate_summary(all_vulnerabilities)
                    })
                    
                    # Alert on critical vulnerabilities
                    critical_vulns = [v for v in all_vulnerabilities if v.get('severity') == 'critical']
                    if critical_vulns:
                        self._send_alerts(critical_vulns)
                        
                except Exception as e:
                    self.logger.error(f"Error in continuous scan: {e}")
                    
                # Wait for next scan
                threading.Event().wait(interval)
                
        # Start scan thread
        scan_thread = threading.Thread(target=scan_loop, daemon=True)
        scan_thread.start()
        
    def _calculate_severity(self, vuln_type: str) -> str:
        """Calculate vulnerability severity."""
        severity_mapping = {
            'sql_injection': 'critical',
            'command_injection': 'critical',
            'buffer_overflow': 'critical',
            'default_credentials': 'critical',
            'xss': 'high',
            'xxe': 'high',
            'weak_crypto': 'high',
            'path_traversal': 'high',
            'weak_hash': 'medium',
            'information_disclosure': 'medium',
            'weak_tls_protocol': 'medium',
            'missing_headers': 'low'
        }
        return severity_mapping.get(vuln_type, 'medium')
        
    def _calculate_confidence(self, vuln_type: str, matched_text: str) -> float:
        """Calculate confidence score for vulnerability detection."""
        # Simple heuristic - would be more sophisticated in production
        base_confidence = 0.7
        
        # Increase confidence for certain indicators
        if vuln_type == 'sql_injection' and any(kw in matched_text.lower() for kw in ['union', 'select', 'drop']):
            base_confidence += 0.2
        elif vuln_type == 'xss' and '<script>' in matched_text.lower():
            base_confidence += 0.2
        elif vuln_type == 'command_injection' and any(c in matched_text for c in [';', '|', '&']):
            base_confidence += 0.15
            
        return min(base_confidence, 1.0)
        
    def _get_code_context(self, lines: List[str], line_num: int, context: int = 3) -> str:
        """Get code context around vulnerability."""
        start = max(0, line_num - context - 1)
        end = min(len(lines), line_num + context)
        
        context_lines = []
        for i in range(start, end):
            prefix = '>>> ' if i == line_num - 1 else '    '
            context_lines.append(f"{i+1:4d}: {prefix}{lines[i]}")
            
        return '\n'.join(context_lines)
        
    def _generate_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate vulnerability summary."""
        summary = {
            'total': len(vulnerabilities),
            'by_severity': {},
            'by_category': {},
            'by_type': {}
        }
        
        for vuln in vulnerabilities:
            # By severity
            severity = vuln.get('severity', 'unknown')
            summary['by_severity'][severity] = summary['by_severity'].get(severity, 0) + 1
            
            # By category
            category = vuln.get('category', 'unknown')
            summary['by_category'][category] = summary['by_category'].get(category, 0) + 1
            
            # By type
            vuln_type = vuln.get('type', 'unknown')
            summary['by_type'][vuln_type] = summary['by_type'].get(vuln_type, 0) + 1
            
        return summary
        
    def _send_alerts(self, vulnerabilities: List[Dict[str, Any]]):
        """Send alerts for critical vulnerabilities."""
        self.logger.warning(f"CRITICAL: {len(vulnerabilities)} critical vulnerabilities detected!")
        for vuln in vulnerabilities:
            self.logger.warning(f"  - {vuln.get('type')}: {vuln.get('description')}")
            
    def _identify_service(self, target: str, port: int) -> str:
        """Identify service running on port."""
        # Simple port-based identification
        service_map = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            80: 'http',
            443: 'https',
            3306: 'mysql',
            5432: 'postgresql',
            6379: 'redis',
            27017: 'mongodb'
        }
        return service_map.get(port, 'unknown')
        
    def _has_default_credentials(self, target: str, port: int, service: str) -> bool:
        """Check for default credentials."""
        # This would attempt login with known defaults
        # For demo purposes, returning False
        return False
        
    def _get_service_version(self, target: str, port: int, service: str) -> Optional[str]:
        """Get service version through banner grabbing."""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((target, port))
            
            # Send probe and get banner
            if service == 'http':
                sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            elif service == 'smtp':
                pass  # SMTP sends banner automatically
                
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            # Extract version from banner
            version_match = re.search(r'(\d+\.\d+(?:\.\d+)?)', banner)
            if version_match:
                return version_match.group(1)
                
        except Exception:
            pass
            
        return None
        
    def _is_outdated_version(self, service: str, version: str) -> bool:
        """Check if service version is outdated."""
        # This would check against latest versions
        # For demo purposes, checking against hardcoded minimums
        min_versions = {
            'nginx': '1.20.0',
            'apache': '2.4.48',
            'openssh': '8.0',
            'mysql': '8.0',
            'postgresql': '13.0'
        }
        
        if service in min_versions:
            return version < min_versions[service]
        return False
        
    def _check_weak_protocols(self, target: str) -> List[str]:
        """Check for weak SSL/TLS protocols."""
        # This would test SSL/TLS connections
        # For demo purposes, returning empty list
        return []
        
    def _check_weak_ciphers(self, target: str) -> List[str]:
        """Check for weak cipher suites."""
        # This would test cipher suite negotiation
        # For demo purposes, returning empty list
        return []
        
    def _check_certificate(self, target: str) -> List[Dict[str, Any]]:
        """Check SSL certificate issues."""
        vulnerabilities = []
        
        # This would check certificate validity, expiration, etc.
        # For demo purposes, returning empty list
        
        return vulnerabilities
        
    def _is_vulnerable_version(self, installed: str, vulnerable: str) -> bool:
        """Check if installed version is vulnerable."""
        # Simple version comparison
        # In production, would use proper version parsing
        if vulnerable.startswith('<'):
            return installed < vulnerable[1:]
        elif vulnerable.startswith('<='):
            return installed <= vulnerable[2:]
        elif vulnerable.startswith('=='):
            return installed == vulnerable[2:]
        return False
        
    def export_results(self, format: str = 'json') -> str:
        """Export scan results."""
        if format == 'json':
            return json.dumps(self.scan_results, indent=2)
        elif format == 'csv':
            # CSV export implementation
            pass
        elif format == 'html':
            # HTML report generation
            pass
        return "" 